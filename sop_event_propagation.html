<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SOP Propagation: (A & B) | (B & ~C)</title>
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f172a 0%, #0a192f 100%);
            color: #e0e0e0;
            margin: 0;
            padding: 12px;
            height: 100vh;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        h1 {
            margin: 0;
            text-align: center;
            color: #4fc3f7;
            font-size: 1.4em;
        }

        .subtitle {
            text-align: center;
            color: #90a4ae;
            margin: 2px 0 10px 0;
            font-size: 0.95em;
        }

        .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
            background: #0d1b2a;
            border: 1px solid #546e7a;
            padding: 10px;
            border-radius: 10px;
        }

        .buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        button {
            background: #1a237e;
            color: #fff;
            border: 1px solid #5c6bc0;
            border-radius: 8px;
            padding: 10px 14px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.15s ease;
            box-shadow: 0 0 8px rgba(79, 195, 247, 0.2);
        }

        button:hover {
            border-color: #4fc3f7;
            transform: translateY(-1px);
        }

        button:active {
            transform: scale(0.98);
        }

        .secondary {
            background: #10263d;
            border-color: #546e7a;
            color: #c5cae9;
            box-shadow: none;
        }

        .status {
            font-family: 'Courier New', monospace;
            font-size: 0.95em;
            color: #cfd8dc;
        }

        .layout {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 10px;
            flex: 1;
            min-height: 0;
        }

        .panel {
            background: #0d1b2a;
            border: 1px solid #546e7a;
            border-radius: 12px;
            padding: 10px;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        .panel-title {
            font-weight: 700;
            color: #cfd8dc;
            margin-bottom: 6px;
        }

        svg {
            flex: 1;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at 20% 20%, rgba(79, 195, 247, 0.08), rgba(13, 27, 42, 0.9));
            border-radius: 10px;
        }

        .gate {
            fill: #10263d;
            stroke: #5c6bc0;
            stroke-width: 2;
        }

        .gate-label {
            fill: #e0e0e0;
            font-weight: 700;
            text-anchor: middle;
            dominant-baseline: middle;
            font-size: 12px;
        }

        .wire {
            stroke: #546e7a;
            stroke-width: 3;
            fill: none;
        }

        .wire.high {
            stroke: #4caf50;
        }

        .wire.low {
            stroke: #ef5350;
        }

        .signal-badge {
            fill: #0a1524;
            stroke: #37474f;
            stroke-width: 1.5;
        }

        .signal-text {
            fill: #e0e0e0;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            text-anchor: middle;
            dominant-baseline: middle;
        }

        .queue-list,
        .history {
            margin: 0;
            padding-left: 18px;
            color: #cfd8dc;
            font-size: 0.95em;
            overflow-y: auto;
        }

        .history {
            flex: 1;
            min-height: 120px;
        }

        .note {
            color: #b0bec5;
            font-size: 0.9em;
            line-height: 1.3;
        }

        .tag {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 8px;
            border-radius: 10px;
            border: 1px solid #546e7a;
            background: rgba(84, 110, 122, 0.15);
            font-family: 'Courier New', monospace;
        }

        .tag-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 2px solid #546e7a;
        }

        .tag-dot.high {
            background: #2e7d32;
            border-color: #66bb6a;
        }

        .tag-dot.low {
            background: #b71c1c;
            border-color: #ef5350;
        }

        .queue-empty {
            color: #90a4ae;
            font-style: italic;
        }

        .gate-highlight {
            filter: drop-shadow(0 0 6px rgba(79, 195, 247, 0.6));
        }
    </style>
</head>

<body>
    <div>
        <h1>Propagation through (A & B) | (B & ~C)</h1>
        <div class="subtitle">A beginner view of event-based simulation: when an input changes, only the affected gates
            re-evaluate, and updates ripple level by level.</div>
    </div>

    <div class="controls">
        <div class="buttons">
            <button id="stepBtn">Process next event</button>
            <button id="resetBtn" class="secondary">Reset</button>
        </div>
        <div class="buttons">
            <label>Next A:
                <select id="selA">
                    <option value="0">0</option>
                    <option value="1">1</option>
                </select>
            </label>
            <label>Next B:
                <select id="selB">
                    <option value="0">0</option>
                    <option value="1">1</option>
                </select>
            </label>
            <label>Next C:
                <select id="selC">
                    <option value="0">0</option>
                    <option value="1">1</option>
                </select>
            </label>
        </div>
        <div class="status" id="status">Queue: empty</div>
    </div>

    <div class="layout">
        <div class="panel">
            <div class="panel-title">Circuit</div>
            <svg id="diagram" viewBox="0 0 780 320" preserveAspectRatio="xMidYMid meet"></svg>
        </div>
        <div class="panel">
            <div class="panel-title">Event queue (left is next)</div>
            <ul id="queueList" class="queue-list"></ul>
            <div class="panel-title" style="margin-top:6px;">What just happened?</div>
            <ul id="history" class="history"></ul>
            <div class="note">Pick the next input combination with the selects. That change is applied together when you
                click <b>Process next event</b>. Any signal flips ripple through the queue until it is empty.</div>
            <div class="note">B feeds both AND gates, so changing B schedules both. If either AND output changes, the OR
                gate is scheduled to update the final output.</div>
        </div>
    </div>

    <script>
        const diagram = document.getElementById('diagram');
        const stepBtn = document.getElementById('stepBtn');
        const resetBtn = document.getElementById('resetBtn');
        const selA = document.getElementById('selA');
        const selB = document.getElementById('selB');
        const selC = document.getElementById('selC');
        const statusEl = document.getElementById('status');
        const queueList = document.getElementById('queueList');
        const historyEl = document.getElementById('history');

        const gates = {
            inv1: { type: 'not', inputs: ['C'], output: 'C_BAR', fanout: ['and2'], x: 170, y: 230 },
            and1: { type: 'and', inputs: ['A', 'B'], output: 'X', fanout: ['or1'], x: 320, y: 70 },
            and2: { type: 'and', inputs: ['B', 'C_BAR'], output: 'Y', fanout: ['or1'], x: 320, y: 190 },
            or1: { type: 'or', inputs: ['X', 'Y'], output: 'F', fanout: [], x: 560, y: 140 }
        };

        const fanoutMap = {
            A: ['and1'],
            B: ['and1', 'and2'],
            C: ['and2', 'inv1'],
            X: ['or1'],
            Y: ['or1'],
            F: [],
            C_BAR: ['and2']
        };

        const state = {
            signals: { A: 0, B: 0, C: 0, C_BAR: 1, X: 0, Y: 0, F: 0 },
            queue: [],
            history: []
        };

        const inputBadges = {
            A: { x: 60, y: 80 },
            B: { x: 60, y: 160 },
            C: { x: 60, y: 240 }
        };

        function gatePorts(g) {
            const w = g.type === 'not' ? 70 : 110;
            const h = g.type === 'not' ? 40 : 60;
            return {
                in1: { x: g.x, y: g.y + h * 0.25 },
                in2: { x: g.x, y: g.y + h * 0.75 },
                out: { x: g.x + w, y: g.y + h * 0.5 },
                width: w,
                height: h
            };
        }

        function gatePath(gate) {
            const { width: w, height: h } = gatePorts(gate);
            if (gate.type === 'and') {
                const r = h / 2;
                // Rounded end AND shape
                return `M${gate.x} ${gate.y} L${gate.x + w - r} ${gate.y} A${r} ${r} 0 0 1 ${gate.x + w - r} ${gate.y + h} L${gate.x} ${gate.y + h} Z`;
            }
            if (gate.type === 'not') {
                const midY = gate.y + h / 2;
                const triW = 60;
                return `M${gate.x} ${gate.y} L${gate.x + triW} ${midY} L${gate.x} ${gate.y + h} Z`;
            }
            // OR shape with curved input side
            const cx = gate.x;
            const cy = gate.y;
            const x2 = gate.x + w;
            const y2 = gate.y + h;
            const midY = cy + h / 2;
            const ctrl = 30;
            return `M${cx} ${cy} Q${cx + ctrl} ${midY} ${cx} ${y2} L${x2 - 20} ${y2} Q${x2 + 10} ${midY} ${x2 - 20} ${cy} Z`;
        }

        function drawDiagram() {
            diagram.innerHTML = '';

            // Wires
            const wireSegments = [];
            const port = {};
            Object.entries(gates).forEach(([id, g]) => {
                port[id] = gatePorts(g);
            });

            // Input badges to AND inputs and inverter
            wireSegments.push({ from: inputBadges.A, to: port.and1.in1, signal: 'A' });
            wireSegments.push({ from: inputBadges.B, to: port.and1.in2, signal: 'B' });
            wireSegments.push({ from: inputBadges.B, to: port.and2.in1, signal: 'B' });
            wireSegments.push({ from: inputBadges.C, to: { x: port.inv1.in1.x, y: inputBadges.C.y }, signal: 'C' });
            wireSegments.push({ from: { x: port.inv1.in1.x, y: port.inv1.in1.y }, to: port.inv1.in1, signal: 'C' });
            wireSegments.push({ from: { x: port.inv1.out.x, y: port.inv1.out.y }, to: port.and2.in2, signal: 'C_BAR' });

            // AND outputs to OR inputs
            wireSegments.push({ from: port.and1.out, to: port.or1.in1, signal: 'X' });
            wireSegments.push({ from: port.and2.out, to: port.or1.in2, signal: 'Y' });

            // OR output to F badge
            wireSegments.push({ from: port.or1.out, to: { x: 700, y: port.or1.out.y }, signal: 'F' });

            wireSegments.forEach(seg => {
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                const midX = (seg.from.x + seg.to.x) / 2;
                // simple dogleg: horizontal to mid, then horizontal into gate
                const d = `M${seg.from.x} ${seg.from.y} L${midX} ${seg.from.y} L${midX} ${seg.to.y} L${seg.to.x} ${seg.to.y}`;
                path.setAttribute('d', d);
                path.setAttribute('class', `wire ${state.signals[seg.signal] ? 'high' : 'low'}`);
                diagram.appendChild(path);
            });

            // Inputs
            Object.entries(inputBadges).forEach(([name, pos]) => {
                badge(name, pos.x, pos.y);
            });

            // Gates
            Object.entries(gates).forEach(([id, g]) => {
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', gatePath(g));
                path.setAttribute('class', 'gate');
                if (state.queue[0] === id) path.classList.add('gate-highlight');
                diagram.appendChild(path);

                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                const { width: w, height: h } = gatePorts(g);
                text.setAttribute('x', g.type === 'not' ? g.x + 30 : g.x + w * 0.55);
                text.setAttribute('y', g.y + h * 0.5);
                text.setAttribute('class', 'gate-label');
                if (g.type === 'and') text.textContent = id === 'and1' ? 'AND1' : 'AND2';
                else if (g.type === 'or') text.textContent = 'OR';
                else text.textContent = 'INV';
                diagram.appendChild(text);

                const outPort = gatePorts(g).out;
                badge(g.output, outPort.x + 30, outPort.y, 18);
            });

            // Output label
            badge('F', 700, port.or1.out.y, 18);
        }

        function badge(name, x, y, offsetY = 0) {
            const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            rect.setAttribute('x', x - 22);
            rect.setAttribute('y', y - 14 + offsetY);
            rect.setAttribute('width', 44);
            rect.setAttribute('height', 28);
            rect.setAttribute('rx', 8);
            rect.setAttribute('class', 'signal-badge');
            group.appendChild(rect);

            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('x', x);
            text.setAttribute('y', y + offsetY);
            text.setAttribute('class', 'signal-text');
            text.textContent = `${name}:${state.signals[name]}`;
            group.appendChild(text);

            diagram.appendChild(group);
        }

        // Simulation logic
        function enqueueGatesForSignal(sig) {
            fanoutMap[sig].forEach(gid => {
                if (!state.queue.includes(gid)) state.queue.push(gid);
            });
        }

        function evaluateGate(gid) {
            const gate = gates[gid];
            const inputs = gate.inputs.map(n => state.signals[n]);
            let outVal = 0;
            if (gate.type === 'and') {
                outVal = inputs.every(Boolean) ? 1 : 0;
            } else if (gate.type === 'or') {
                outVal = inputs.some(Boolean) ? 1 : 0;
            } else if (gate.type === 'not') {
                outVal = inputs[0] ? 0 : 1;
            }
            const prev = state.signals[gate.output];
            const changed = prev !== outVal;
            state.signals[gate.output] = outVal;
            if (changed) {
                enqueueGatesForSignal(gate.output);
            }
            return { changed, outVal, prev, gate };
        }

        function processEvent() {
            clearHistory();
            const desired = {
                A: Number(selA.value),
                B: Number(selB.value),
                C: Number(selC.value)
            };

            const changes = [];
            Object.keys(desired).forEach(name => {
                const prev = state.signals[name];
                const next = desired[name];
                if (prev !== next) {
                    state.signals[name] = next;
                    changes.push(`${name}:${prev}→${next}`);
                    enqueueGatesForSignal(name);
                }
            });

            if (changes.length) {
                log(`Inputs changed: ${changes.join(', ')}; scheduling affected gates.`);
            } else {
                log('Inputs unchanged; processing any pending gate evaluations.');
            }

            const gateActions = { INV: null, AND1: null, AND2: null, OR: null };
            while (state.queue.length > 0) {
                const gid = state.queue.shift();
                const { changed, outVal, prev, gate } = evaluateGate(gid);
                const changeText = changed ? `output changed ${prev}→${outVal}, scheduled fanout.` : 'output unchanged; no further scheduling.';
                let label = 'OR';
                let step = '2';
                if (gate.type === 'and') {
                    label = gid === 'and1' ? 'AND1' : 'AND2';
                    step = label === 'AND1' ? '1a' : '1b';
                } else if (gate.type === 'not') {
                    label = 'INV';
                    step = '0';
                }
                gateActions[label] = `${step} - ${label}: inputs ${gate.inputs.map(i => `${i}=${state.signals[i]}`).join(', ')} → ${gate.output}=${outVal}; ${changeText}`;
            }

            const order = ['INV', 'AND1', 'AND2', 'OR'];
            const anyAction = order.some(k => gateActions[k] !== null);
            if (!anyAction && changes.length === 0) {
                log('Queue empty. Nothing to update.');
            }
            order.forEach(k => {
                const step = k === 'INV' ? '0' : (k === 'AND1' ? '1a' : (k === 'AND2' ? '1b' : '2'));
                log(gateActions[k] || `${step} - ${k}: not scheduled this step.`);
            });

            render();
        }

        function log(text) {
            const li = document.createElement('li');
            li.textContent = text;
            historyEl.appendChild(li);
            while (historyEl.childElementCount > 8) historyEl.removeChild(historyEl.firstChild);
        }

        function clearHistory() {
            historyEl.innerHTML = '';
        }

        function updateQueueView() {
            queueList.innerHTML = '';
            if (state.queue.length === 0) {
                const li = document.createElement('li');
                li.textContent = 'empty';
                li.className = 'queue-empty';
                queueList.appendChild(li);
                return;
            }
            state.queue.forEach((gid, idx) => {
                const li = document.createElement('li');
                li.textContent = `${idx === 0 ? '▶ ' : ''}${gid} (reads ${gates[gid].inputs.join(', ')} → ${gates[gid].output})`;
                queueList.appendChild(li);
            });
        }

        function render() {
            drawDiagram();
            updateQueueView();
            statusEl.textContent = `Queue length: ${state.queue.length} | Signals: ${Object.entries(state.signals).map(([k, v]) => `${k}=${v}`).join(' ')}`;
        }

        function reset(silent = false) {
            state.signals = { A: 0, B: 0, C: 0, C_BAR: 1, X: 0, Y: 0, F: 0 };
            state.queue = [];
            historyEl.innerHTML = '';
            selA.value = '0';
            selB.value = '0';
            selC.value = '0';
            if (!silent) {
                log('Reset pressed: signals forced to 0; queue cleared. Stage new inputs with the dropdowns, then Process next event.');
            }
            render();
        }

        stepBtn.addEventListener('click', processEvent);
        resetBtn.addEventListener('click', () => reset(false));

        reset(true);
    </script>
</body>

</html>
